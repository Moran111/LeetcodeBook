# 31.Next Permutation



Implement **next permutation**, which rearranges numbers into the lexicographically next greater permutation of numbers.

If such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).

The replacement must be [**in place**](http://en.wikipedia.org/wiki/In-place\_algorithm) and use only constant extra memory.

&#x20;

**Example 1:**

```
Input: nums = [1,2,3]
Output: [1,3,2]
```

**Example 2:**

```
Input: nums = [3,2,1]
Output: [1,2,3]
```

**Example 3:**

```
Input: nums = [1,1,5]
Output: [1,5,1]
```

**Example 4:**

```
Input: nums = [1]
Output: [1]
```

&#x20;

**Constraints:**

* `1 <= nums.length <= 100`
* `0 <= nums[i] <= 100`

```
// Some code
class Solution {
    public void nextPermutation(int[] nums) {
        int changePosition = findPositionToChange(nums);
        if (changePosition != -1) {
            int largerNumber = findLargerNumber(nums, changePosition);
            // swap
            int temp = nums[changePosition];
            nums[changePosition] = nums[largerNumber];
            nums[largerNumber] = temp;
        }
        
        // sort after the change position
        Arrays.sort(nums, changePosition+1, nums.length);
    }
    
    private int findPositionToChange(int[] nums) {
        for (int i = nums.length-1; i >= 1; i--) {
            if (nums[i-1] < nums[i]) {
                return i-1;
            }
        }
        return -1;
    }
    
    // idx  a1 a2 a3 .. an -> a1 > a2 > a3 > ... > an
    private int findLargerNumber(int[] nums, int idx) {
        int res = 0;
        int i = idx + 1; 
        while(i < nums.length && nums[i] > nums[idx]) {
            res = i;
            i++;
        }
        return res;
    }
}
```
